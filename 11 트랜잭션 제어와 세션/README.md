# 트랜잭션 제어와 세션

## 하나의 단위로 데이터를 처리하는 트랜잭션

### 트랜잭션이란?
- 관계형 데이터베이스에서 하나의 작업 또는 밀접하게 연관되어 있는 작업 수행을 위해 나눌 수 없는 최소 수행 단위를 트랜잭션이라고 합니다.
- SQL 문법 중 이러한 트랜잭션을 제어하는 데 사용하는 명령어를 TCL 이라고 합니다.

## 트랜잭션을 제어하는 명령어
- 트랜잭션의 개념을 통해 알 수 있듯이 하나의 트랜잭션에 묶여 있는 데이터 조작어(DML)의 수행 상태는 모든 명령어가 정상적으로 수행 완료된 상태 또는 모든 명령어가 수행되지 않아 취소된 상태, 이 두 가지 상태로만 존재할 수 있습니다. 
- 트랜잭션 제어 명령어는 데이터 조작 상태를 이 두 가지 상태 중 하나로 유도하는 명령어를 의미합니다. 즉, 데이터 조작을 데이터베이스에 영구히 반영하거나 작업 전체를 취소합니다.

- DEPT 테이블을 복사해서 DEPT_TCL 테이블 만들기

```
CREATE TABLE DEPT_TCL 
	AS SELECT * FROM DEPT;
	
SELECT * FROM DEPT_TCL;
```

- DEPT_TCL 테이블에 데이터를 입력,수정,삭제하기

```
INSERT INTO DEPT_TCL VALUES(50, 'DATABASE', 'SEOUL');

UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 40;

DELETE FROM DEPT_TCL WHERE DNAME = 'RESEARCH';

SELECT * FROM DEPT_TCL;
```

- ROLLBACK으로 명령어 실행 취소하기

```
ROLLBACK

SELECT * FROM DEPT_TCL;
```

- 결과를 살펴보면 최소 DEPT_TCL 테이블을 생성한 직후의 데이터로 되돌아간 것을 확인할 수 있습니다. 즉 앞에서 실행한 데이터 조작 관련 명령어 실행이 모두 취소되었습니다.

### 트랜잭션을 영원히 반영하고 싶을 때는 COMMIT
- ROLLBACK과 달리 지금까지 수행한 트랜잭션 명령어를 데이터베이스에 영구히 반영할 때는 COMMIT 명령어를 사용합니다.

- DEPT_TCL 테이블에 데이터를 입력,수정,삭제하기

```
INSERT INTO DEPT_TCL VALUES(50, 'NETWORK', 'SEOUL');

UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 20;

DELETE FROM DEPT_TCL WHERE DEPTNO = 40;

SELECT * FROM DEPT_TCL;
```

- COMMIT으로 명령어 반영하기

```
COMMIT;
```

- COMMIT 명령어는 지금까지 트랜잭션에서 데이터 조작 관련 명령어를 통해 변경된 데이터를 모두 데이터베이스에 영구히 반영합니다. 즉 COMMIT 명령어 사용을 기점으로 50번 부서 추가, 20번 부서의 LOC 열 변경, 40번 부서 삭제는 취소가 불가능합니다.  ROLLBACK 명령어 역시 이 시점부터는 소용없습니다. 그러므로 COMMIT은 트랜잭션 작업이 정상적으로 수행되었다고 확신할 때 사용해야 합니다.

- 트랜잭션 제어 명령어를 소개한 시점에 수행한 DEPT_TCL 테이블 생성부터 COMMIT 실행 까지 트랜잭션 시작과 종료 과정을 다음 그림으로 표현하였습니다.

![image1](https://raw.githubusercontent.com/yonggyo1125/curriculumOracle/master/11%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20%EC%A0%9C%EC%96%B4%EC%99%80%20%EC%84%B8%EC%85%98/images/image1.png)

|COMMIT, ROLLBACK 명령어 모두 현재 트랜잭션을 끝내고 새 트랜잭션을 시작하게 합니다. 종료될 트랜잭션에 작업을 반영할지 취소할지만 결정하는 것입니다.

* * * 
## 세션과 읽기 일관성의 의미

### 세션이란?
- 일반적으로 세션(session)은 어떤 활동을 위한 시간이나 기간을 뜻합니다. 오라클 데이터베이스에서 세션은 데이터베이스 접속을 시작으로 여러 데이터베이스에서 관련 작업을 수행한 후 접속을 종료하기까지 전체 기간을 의미합니다. 
- 좀 더 익숙한 단어로 표현한다면 게임이나 웹 서비스에 로그인해서 로그아웃할 때까지의 기간 또는 모바일이나 온라인 게임등을 켜고 끌 때까지의 기간 정도로 생각해도 됩니다.
- 세션이 여러 개라는 말은 현재 오라클 데이터베이스에 접속하여 사용 중인 연결이 여러 개 있다는 뜻입니다. 예를 들어 현재 우리가 사용하고 있는 오라클 데이터베이스에 토드를 사용하여 SCOTT 계정으로 접속했을 때, 명령어 프롬프트를 켜서 SQL\*PLUS를 실행하여 SCOTT으로 접속할 경우에 세션은 두 개가 됩니다.

- 트랜잭션과 세션의 관계를 살펴보면 트랜잭션은 데이터 조작 명령어가 모인 하나의 작업 단위를 뜻하며 세션 내부에는 하나 이상의 트랜잭션이 존재합니다. 왜냐하면 데이터베이스에 접속한 후 종료하기까지의 과정이 하나의 세션이고 이 세션이 유지되는 동안 여러 COMMIT, ROLLBACK 작업이 진행되기 때문입니다. 세션이 트랜잭션보다 큰 범위의 개념입니다.

![image2](https://raw.githubusercontent.com/yonggyo1125/curriculumOracle/master/11%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20%EC%A0%9C%EC%96%B4%EC%99%80%20%EC%84%B8%EC%85%98/images/image2.png)

### 읽기 일관성의 중요성
- 데이터베이스는 여러 곳(여러 사용자, 여러 응용 프로그램)에서 동시에 접근하여 데이터를 관리,사용하는 것이 목적이므로 대부분 수많은 세션이 동시에 연결되어 있습니다. 
- 읽기 일관성이란 어떤 특정 세션에서 테이블의 데이터를 변경 중일 때 그 외 다른 세션에서는 데이터의 변경이 확정되기 전까지 변경 사항을 알 필요가 없으므로, 데이터를 변경 중인 세션을 제외한 나머지 세션에서는 현재 진행 중인 변경과 무관한 본래의 데이터를 보여주는 특성을 의미합니다.

- 이 문제를 확인하기 위해 다른 실습과는 다르게 오라클 데이터베이스에 두 세션으로 각각 실습을 수행해 보겠습니다. 실습에 앞서 세션 두개를 띄어 봅시다. dbweaver와 명령 프롬프트에서 SQL\*PLUS를 실행하여 각각 SCOTT 계정으로 오라클 데이터베이스에 접속합니다. 이제부터 dbweaver를 사용한 세션을 A, SQL\*PLUS를 사용한 세션은 세션 B라고 하겠습니다. 
- DEPT_TCL 테이블을 활용하여 세션 A, B에서 모두 DEPT_TCL 테이블을 조회합니다.

- dbweaver와 SQL\*PLUS로 세션 알아보기
|세션 A(dbweaver)|세션 B(SQL\*PLUS)|
|----|----|
|SELECT \* FROM DEPT_TCL; - (1)|SELECT \* FROM DEPT_TCL; - (2)|

|세션 A,B 모두 SCOTT 계정으로 접속합니다.|

- 두 세션 모두 똑같은 DEPT_TCL 테이블을 조회했으므로 조회 결과는 같습니다.
- 이번에는 세션 A에서 DELETE문을 사용하여 50번 부서 데이터를 삭제한 후에 각 세션에서 DEPT_TCL 테이블을 조회합니다. 다음을 순서대로 dbweaver와 SQL\*PLUS에서 실행합니다.

|세션 A(dbweaver)|세션 B(SQL\*PLUS)|
|----|----|
|DELETE FROM DEPT_TCL<br>WHERE DEPTNO = 50; - (1) |세션 A의 DELETE 명령이 끝날 때까지 기다려 주세요.|
|SELECT \* FROM DEPT_TCL; - (2)|SELECT \* FROM DEPT_TCL; - (3)|

- 세션 A에서는 50번 부서가 삭제된 상태로 DEPT_TCL 테이블이 조회되지만 세션 B에서는 50번 부서가 아직 삭제되지 않은 상태, 즉 변경이 일어나기 전 상태로 출력됩니다.

- 이는 세션 A에서 실행한 DELETE문의 수행 결과가 데이터베이스에 완벽하게 반영되지 않았기 때문입니다. 즉 COMMIT되지 않았다는 이야기입니다. 
- 실행한 DELETE문의 실행 결과가 데이터베이스에 영구히 반영되기 전까지 DELETE를 실행한 세션 A를 제외한 다른 세션에서는 50번 부서 데이터의 변화를 확인할 수 없습니다. 따라서 50번 부서의 삭제를 확인할 수 있는 것은 세션 A뿐 입니다.
- 이와 같이 어떤 데이터 조작이 포함된 트랜잭션이 완료(COMMIT, ROLLBACK)되기 전까지 데이터를 직접 조작하는 세션 외 다른 세션에서는 데이터 조작 전 상태의 내용이 일관적으로 조회,출력,검색되는 특성을 '읽기 일관성(read consistency)'이라고 합니다.

- 세션 A에서 COMMIT을 실행한 후 각 세션에서 다시 DEPT_TCL 테이블을 조회합니다.

|세션 A(dbweaver)|세션 B(SQL\*PLUS)|
|----|----|
|COMMIT; - (1)|세션 A의 COMMIT 명령이 끝날 때까지 기다려 주세요.|
|SELECT \* FROM DEPT_TCL; - (2)|SELECT \* FROM DEPT_TCL; - (3)|

- 세션 A에서 COMMIT 실행 후에는 50번 부서를 삭제하는 DELETE문 수행 결과가 데이터베이스에 완전히 반영됩니다. 따라서 세션 B에서도 50번 부서가 삭제된 채 조회되는 것을 확인할 수 있습니다.

- 하나의 데이터베이스에서는 수많은 세션이 연결되고 각 세션에서는 데이터 조작 명령어가 포함된 여러 트랜잭션이 끊임없이 시작되고 종료되면서 실시간으로 작업이 수행됩니다. 데이터를 직접 변경 중인 해당 세션을 제외한 모든 세션은 다른 세션의 데이터 변경과 상관없이 이미 확정된 데이터만 검색됨으로써 읽기 일관성을 보장할 수 있습니다.

### 정리
- 오라클 데이터베이스에서 세션은 데이터베이스 접속 시작부터 접속이 종료되기까지 전체 기간을 의미합니다.
- 하나의 세션은 여러 SQL문이 하나의 작업 단위로 다뤄지는 여러 개의 트랜잭션으로 구성됩니다. 트랜잭션 작업을 데이터베이스에 영구히 반영할 때 COMMIT 명령어를 사용하고 지금까지 한 작업을 취소할 때 ROLLBACK 명령어를 사용합니다. 이 명령어를 통해 현재 트랜잭션이 종료될 때까지 다른 세션에서는 데이터 조회 전 상태의 데이터만 조회할 수 있으며 이러한 특성을 읽기의 일관성 이라고 합니다.

* * * 
## 수정 중인 데이터 접근을 막는 LOCK

### LOCK 이란?
- 특정 세션에서 조작중인 데이터는 트랜잭션이 완료(COMMIT, ROLLBACK)되기 전까지 다른 세션에서 조작할 수 없는 상태가 됩니다. 즉 데이터가 잠기는(LOCK) 것입니다. 
- '잠금', '잠금 현상'으로도 표현하는 LOCK은 조작 중인 데이터를 다른 세션은 조작할 수 없도록 접근을 보류시키는 것을 뜻합니다.

### LOCK 개념 살펴보기
- LOCK 또한 세션 A와 세션 B로 나눠 각각 dbweaver 및 SQL\*PLUS를 사용하여 SCOTT으로 접속한 후 진행합니다.

- dbweaver와 SQL\*PLUS로 LOCK 알아보기

|세션 A(dbweaver)|세션 B(SQL\*PLUS)|
|----|----|
|SELECT \* FROM DEPT_TCL; - (1)|SELECT \* FROM DEPT_TCL; - (2)|

- DEPT_TCL 테이블에 데 이상 별다른 작업을 진행하지 않았다면 데이터는 동일하게 출력됩니다.

- 세션 A에서 30번 부서에 UPDATE문을 사용하여 데이터를 변경해보겠습니다.
- dbweaver와 SQL\*PLUS로 LOCK 알아보기

|세션 A(dbweaver)|세션 B(SQL\*PLUS)|
|----|----|
|UPDATE DEPT_TCL SET LOC='SEOUL'<br>WHERE DEPTNO = 30; - (1)|세션 A의 UPDATE 명령이 끝날 때까지 기다려 주세요.|
|SELECT \* FROM DEPT_TCL; - (2)|SELECT \* FROM DEPT_TCL; - (3)|

- 앞의 세션 때와 마찬가지로 UPDATE문을 실행하고 있는 세션 A에서는 30번 부서의 LOC 열이 SEOUL로 변경되었지만 COMMIT은 되지 않은 상태이므로 세션 B에서는 30번 부서에 변화가 없습니다. 

- 이 상태에서 세션 B의 30번 부서에(세션 A가 변경 중인)에 UPDATE문을 실행해 보겠습니다. 
- dbweaver와 SQL\*PLUS로 LOCK 알아보기

|세션 A(dbweaver)|세션 B(SQL\*PLUS)|
|----|----|
|A는 아무런 작업을 하지 않습니다.|UPDATE DEPT_TCL SET DNAME='DATABASE'<br>WHERE DEPTNO = 30; - (1)|

- 세션 B에서 UPDATE문을 작성하고 실행하면 아무런 동작이 일어나지 않습니다. SQL\*PLUS화면을 보면 화면이 멈춘듯 가만히 있을 겁니다.

- 이는 세션 A에서 DEPT_TCL 테이블의 30번 부서 데이터를 먼저 조작하고 있기 때문입니다. 세션 A에서 수행 중인 30번 부서 행 데이터의 조작이 완료되지 않았기 때문에 COMMIT 또는 ROLLBACK을 수행하기 전까지 30번 부서 행 데이터를 조작하려는 다른 세션은 작업을 대기하게 됩니다. 이렇게 특정 세션에서 데이터 조작이 완료될 때까지 다른 세션에서 해당 데이터 조작을 기다리는 현상을 HANG(행)이라고 합니다.

- 세션 B의 UPDATE문은 세션 A의 현재 트랜잭션이 종료되기 전까지는 수행되지 못합니다. 즉 세션 A에서 COMMIT으로 데이터 변경을 확정하여 반영하거나, ROLLBACK으로 세션 A의 UPDATE문 실행을 취소해야만 30번 부서 데이터의 LOCK이 풀립니다. 그리고 데이터의 LOCK이 풀린 즉시 세션 B는 UPDATE문을 실행합니다.

- 그러면 세션 A에서 COMMIT 명령어를 실행해보겠습니다. 

|세션 A(dbweaver)|세션 B(SQL\*PLUS)|
|----|----|
|COMMIT; - (1)|세션 A의 COMMIT 명령어가 실행되는 순간의 변화를 확인합니다.|

- 세션 A에서 COMMIT 명령어를 실행하는 순간 세션 B의 UPDATE 문이 실행된 것을 확인할 수 있습니다. 세션 A에 의해 LOCK 상태였던 30번 부서 데이터가 COMMIT 명령어로 트랜잭션이 완료되어 LOCK이 풀렸고, 이와 동시에 30번 부서 데이터 작업을 기다리고 있던  세션 B의 UPDATE문이 실행된 것 입니다.

- 각 세션에서 다시 DEPT_TCL 테이블을 조회하면

|세션 A(dbweaver)|세션 B(SQL\*PLUS)|
|----|----|
|SELECT \* FROM DEPT_TCL;|SELECT \* FROM DEPT_TCL;|

- 세션 A의 LOCK이 풀린 후 세션 B의 UPDATE문이 실행되었지만 아직 COMMIT을 하지 않은 상태이기 때문에 세션 B에서만 30번 부서의 DNAME 열이 DATABASE로 출력 됩니다. 그러므로 세션 B에서 COMMIT을 실행하면 세션 A에서도 30번 부서의 DNAME이 변경된 것을 확인할 수 있습니다.

- 세션 B(SQL\*PLUS)

```
COMMIT
```

-  세션 A(dbweaver)

```
SELECT \* FROM DEPT_TCL;
```

### LOCK 종류
- LOCK은 하나의 데이터를 여러 곳에서 동시에 조작하려 할 때 발생할 수 있는 혼란을 최소화하기 위해 중요한 요소입니다. 
- SQL문으로 조작하는 대상 데이터가 테이블의 특정 행 데이터일 경우에 해당 행만 LOCK이 발생한다는 의미로 '행 레벨 록(row level lock)' 이라고 정의합니다.
- 만약 다음과 같이 WHERE절을 지정하지 않은 UPDATE, DELETE문일 경우에는 테이블의 모든 행 데이터에 영향을 주는 명령어이므로 이 경우에는 테이블에 저장되어 있는 전체 행이 LOCK 상태가 됩니다. 즉 다른 세션에는 해당 테이블에 이미 저장되어 있는 행에 UPDATE, DELETE 명령을 수행하기 위해서 대기해야 합니다. 
- 하지만 테이블 전체 행이 LOCK 상태여도 INSERT 문의 수행은 가능합니다.

```
UPDATE DEPT_TCL SET LOC = 'SEOUL';

DELETE FROM DEPT_TCL;
```

- 하지만 테이블에 변경되는 행의 수와는 상관없이 데이터 조작 명령어를 사용하여 데이터가 변경 중인 테이블은 테이블 단위 잠금이라는 의미로 '테이블 레벨 록(table level lock)'이 걸리게 됩니다. 즉 데이터를 변경 중인 세션 외 다른 세션에서는 데이터 정의어(DDL)을 통한 테이블 구조를 변경할 수는 없습습니다.
- 데이터 조작 관련 SQL문을 어떤 방식으로 작성하느냐에 따라 테이블의 일부 데이터만 LOCK이 될 수도 있고 테이블 전체 데이터가 LOCK이 될 수도 있습니다.